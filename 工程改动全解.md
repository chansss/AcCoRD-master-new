# 工程改动全解（从 upstream 到两轮升级：逐文件、逐机制、逐调用链）

这份文档的目标是：把“你在别人项目 AcCoRD 上到底改了什么”讲到学生能顺着代码一路走到底、问任何问题都能在这里定位到答案。

本文档按两条主线组织：
- **时间线**：你做了哪些提交、每次升级在解决什么问题。
- **代码链路**：从 `main()` 开始，沿着仿真执行流，把每个你改过的模块/文件讲清楚（改了什么、怎么改、为什么这么改、与哪些文件协作）。

---

## 0. 读者导航（学生怎么读）

建议学生按这个顺序看：
1. **先看仿真总流程**：第 2 章（`accord.c` 的主循环在干什么）。
2. **再看第一轮性能改造**：第 3 章（SoA/Pool、观测存储改造、批量 RNG、受控集成与验证）。
3. **最后看第二轮升级（依赖 Actor + AF 转发）**：第 4 章（触发条件、强度映射、定时器堆、配置解析）。

每一节都给了“代码入口点”和“关键结构/函数”的链接（点击可以直接跳到对应行）。

---

## 1. 你做过的提交（按时间顺序）

仓库的提交链（从 `init project` 到当前 `HEAD`）如下：

- `f79abe3`：init project（导入 upstream 工程基线）
- `68a8863`：第一版（第一轮性能改造：SoA/Pool 原型 + benchmark + 论文初稿）
- `04badfb`：第二版（第一轮性能改造迭代：进一步把 SoA 连接到真实仿真路径）
- `6fcdd32`：最终版（第一轮性能改造收敛：RNG 批量化、观测结构改造、论文完善）
- `87efa10`：新增运行说明（后续又被删除/替换，不影响核心代码）
- `c428cff`：change（README 系列整理，运行说明调整）
- `c9ee707`：提交 win运行（开始尝试提供 Windows 运行物：exe/调试产物；引入平台相关头文件处理）
- `119f579`：上传原版可执行 exe（保留原始 exe 版本对比）
- `1087059`：根据老师建议 改动（第二轮升级：依赖 Actor + AF 转发链路 + 定时器堆修复 + update.md）
- `9486ba6`：新增问题解答 + 全自动对比脚本（教学配套：Q&A、脚本、对比总结）
- `640d289`：更新 bin（更新可执行/benchmark 二进制）

你做的两轮升级可归纳为：
- **第一轮（性能升级）**：把“微观分子链表 AoS”引入 SoA（MicroMoleculePool）并做可控集成；同时改造观测数据结构，减少链表复制开销；补齐基准测试与论文说明。
- **第二轮（功能/模型升级）**：实现依赖型主动 Actor（dependent active actor）并扩展为 AF（Amplify-and-Forward）转发；修复定时器堆更新问题；补齐配置解析与样例。

---

## 2. 仿真总流程（从 `main()` 到每一步发生什么）

### 2.1 总入口：`src/accord.c`

AcCoRD 的主程序在 [accord.c](file:///Users/faner/Documents/AcCoRD-master/src/accord.c) 的 `main()`。你对它的改动主要集中在：
- **第一轮**：增加 SoA-simple 的“受控启用”逻辑，把 `MicroMoleculePool` 挂到真实仿真循环里（但只在非常严格的前提下启用）。
- **第二轮**：在“被动 Actor 完成一次观测”之后，驱动“依赖主动 Actor”触发并进行 AF 映射释放。

#### 2.1.1 关键阶段划分（学生要背下来的 4 步）

AcCoRD 主程序可以概括为：
1. **读配置**：`loadConfig(...)`（[file_io.c](file:///Users/faner/Documents/AcCoRD-master/src/file_io.c)）
2. **初始化环境**：regions/subvolumes/reactions/actors/timers
3. **跑主循环**：每次取 heap 里的“最早事件”，推进时间并执行对应事件
4. **输出与清理**：写结果文件、释放内存

你新增/修改的优化点，分别嵌入在第 2、3、4 步中。

---

## 3. 第一轮性能升级：从链表 AoS 到 SoA（MicroMoleculePool）+ 观测存储改造 + 批量 RNG

这一轮对应的“论文叙述”主要在 [research_paper.md](file:///Users/faner/Documents/AcCoRD-master/research_paper.md)。

### 3.1 问题定义：为什么链表慢

upstream 的微观分子存储是“每个分子一个节点”，并用链表串起来：遍历时会发生大量不连续内存访问，cache miss 多、分支预测差，也很难 SIMD/并行。

你的思路不是换算法，而是先换**数据布局**：把 `(x,y,z,bNeedUpdate)` 从“每个分子一个 struct”改为“每个字段一条连续数组”（Structure of Arrays, SoA）。

---

### 3.2 核心新结构：`MicroMoleculePool`（SoA）

#### 3.2.1 结构定义与接口（`src/micro_molecule.h`）

你在 [micro_molecule.h:L143-L274](file:///Users/faner/Documents/AcCoRD-master/src/micro_molecule.h#L143-L274) 新增了：

```c
struct MicroMoleculePool {
  double* x;
  double* y;
  double* z;
  bool* bNeedUpdate;
  size_t count;
  size_t capacity;
};
```

并在同一文件内给了“最小可用”的池操作（内联）：
- `pool_init(...)`：分配数组、初始化 `count/capacity`（[micro_molecule.h:L187-L203](file:///Users/faner/Documents/AcCoRD-master/src/micro_molecule.h#L187-L203)）
- `pool_add_molecule(...)`：push-back；满了就 `realloc` 扩容（[micro_molecule.h:L204-L230](file:///Users/faner/Documents/AcCoRD-master/src/micro_molecule.h#L204-L230)）
- `pool_remove_molecule(...)`：swap-with-last + pop（O(1) 删除，不保持顺序）（[micro_molecule.h:L232-L245](file:///Users/faner/Documents/AcCoRD-master/src/micro_molecule.h#L232-L245)）
- `pool_free(...)`：释放各数组（[micro_molecule.h:L247-L263](file:///Users/faner/Documents/AcCoRD-master/src/micro_molecule.h#L247-L263)）

**为什么这么做**
- `swap-and-pop` 的删除策略是典型 data-oriented 取舍：不要“顺序稳定性”，换取 O(1) 删除；在分子仿真里分子本来就无序，因此这是合理的。
- pool 接口写在头文件内联，是为了减少函数调用开销，并让编译器更容易优化。

---

### 3.3 把 Pool 挂到 Region：生命周期归 region 管

#### 3.3.1 region 结构增加 `molPool`（`src/region.h`）

你在 [region.h:L576-L579](file:///Users/faner/Documents/AcCoRD-master/src/region.h#L576-L579) 给 `struct region` 增加：

```c
struct MicroMoleculePool * molPool;
```

并做了一个前置声明避免循环 include（[region.h:L182-L185](file:///Users/faner/Documents/AcCoRD-master/src/region.h#L182-L185)）。

**为什么这样挂**
- 微观分子“属于某个 region”，所以 pool 的所有权自然应该在 region 生命周期内创建/释放；
- 这样不会改变原本 `microMolList[region][type]` 的接口，便于“受控地逐步替换”。

#### 3.3.2 region 初始化时创建 pool（`src/region.c`）

在 [region.c:L306-L321](file:///Users/faner/Documents/AcCoRD-master/src/region.c#L306-L321)：
- 只给 `bMicro` 的 region 分配 `molPool`
- 初始容量固定为 1000（原型阶段的默认值）

#### 3.3.3 region 释放时销毁 pool（`src/region.c`）

在 [region.c:L628-L633](file:///Users/faner/Documents/AcCoRD-master/src/region.c#L628-L633)：
- `pool_free(...)`
- `free(regionArray[i].molPool)`

**为什么必须放在 delete_boundary_region_**
- upstream 的 region 释放都集中在 `delete_boundary_region_`，你沿用了工程风格，避免引入新的释放路径导致泄露。

---

### 3.4 “受控启用”的 SoA-simple：只在简单配置下启用

你没有直接把整个仿真从链表重写成 pool，而是先做“简单场景受控启用（guarded integration）”：

#### 3.4.1 三个全局开关变量（`src/micro_molecule.c/.h`）

在 [micro_molecule.c:L114-L116](file:///Users/faner/Documents/AcCoRD-master/src/micro_molecule.c#L114-L116) 定义：
- `gSoaSimpleEnabled`
- `gSoaSimplePool`
- `gSoaSimpleList`

并在 [micro_molecule.h:L175-L177](file:///Users/faner/Documents/AcCoRD-master/src/micro_molecule.h#L175-L177) 声明为 `extern`。

这三个变量的语义是：
- **是否启用** SoA-simple 模式；
- 哪个 region 的 `molPool` 是目标池；
- 哪个 `ListMol3D*`（链表）对应这个池（用于“对齐”某个 `(region, molType)`）。

#### 3.4.2 在 `main()` 初始化阶段决定是否开启（`src/accord.c`）

你在 [accord.c:L250-L307](file:///Users/faner/Documents/AcCoRD-master/src/accord.c#L250-L307) 增加了启用逻辑：
- 仅当设置环境变量 `ACCORD_USE_SOA_SIMPLE` 才尝试启用；
- 严格筛选 region：
  - 微观 region
  - 没有化学反应
  - 没有 meso 邻居
  - 非 surface
  - 没有 APMC
  - 没有 hybrid（`MAX_HYBRID_DIST <= 0`）
  - `molPool` 已分配
- 并要求全系统只能找到 **唯一一个**满足条件的 `(region, molType)`（否则拒绝启用）。

最后把 `gSoaSimplePool` 和 `gSoaSimpleList` 指向目标：

```c
gSoaSimplePool = regionArray[soaRegion].molPool;
gSoaSimpleList = &microMolList[soaRegion][soaType];
```

**为什么必须这么严格**
- 你在这一阶段的目标是“验证数据布局改造的可行性”，而不是一次性覆盖所有复杂物理/几何边界条件；
- 复杂场景中涉及跨 region 迁移、meso-micro 交换、surface 反应等，会让“pool 与链表一致性”变成系统性工程，必须先把最小闭环跑通。

---

### 3.5 SoA-simple 扩散内核：`diffuseMolecules_pool_simple`

核心实现位于 [micro_molecule.c:L172-L312](file:///Users/faner/Documents/AcCoRD-master/src/micro_molecule.c#L172-L312)。

它的逻辑（学生要逐行读明白）可以拆成 6 步：

1. **早退出**：pool 为空、该类型不扩散也不流动等直接返回（[micro_molecule.c:L202-L208](file:///Users/faner/Documents/AcCoRD-master/src/micro_molecule.c#L202-L208)）。
2. **批量生成扩散增量**：若 `bDiffuse`，分配 `dx/dy/dz` 三个数组（长度 `pool->count`），并调用 `generateNormalArray`（[micro_molecule.c:L212-L234](file:///Users/faner/Documents/AcCoRD-master/src/micro_molecule.c#L212-L234)）。
3. **按 SoA 更新每个分子的位置**：
   - 读取 `oldPoint = (x[i],y[i],z[i])`
   - `newPoint = oldPoint + d? + flow?`
   - 这里 flow 复用 region 现有 `flowConstant`（[micro_molecule.c:L246-L262](file:///Users/faner/Documents/AcCoRD-master/src/micro_molecule.c#L246-L262)）。
4. **复用 upstream 的几何合法性检查**：直接调用 `validateMolecule(...)`（[micro_molecule.c:L271-L287](file:///Users/faner/Documents/AcCoRD-master/src/micro_molecule.c#L271-L287)）。
5. **处理结果**：
   - 若不合法：回滚到 `oldPoint`（[micro_molecule.c:L289-L295](file:///Users/faner/Documents/AcCoRD-master/src/micro_molecule.c#L289-L295)）
   - 若发生 region transition：直接报错并退出（因为这不属于 simple 场景）（[micro_molecule.c:L297-L301](file:///Users/faner/Documents/AcCoRD-master/src/micro_molecule.c#L297-L301)）
   - 否则写回 pool 坐标（[micro_molecule.c:L302-L304](file:///Users/faner/Documents/AcCoRD-master/src/micro_molecule.c#L302-L304)）
6. **释放 dx/dy/dz**（[micro_molecule.c:L306-L311](file:///Users/faner/Documents/AcCoRD-master/src/micro_molecule.c#L306-L311)）。

**这个内核的关键点**
- 你把“随机数生成”和“坐标更新”拆开：先批量生成增量数组，再在主循环里做纯数组加法；
- 这样做的目的之一是让 CPU cache 更友好，同时为未来 SIMD/并行铺路；
- 你没有重写 `validateMolecule`，而是复用 upstream 的几何/边界逻辑，确保物理语义一致。

---

### 3.6 与链表共存：为什么 `addMolecule` 要分流

即使启用 SoA-simple，系统里仍然大量代码仍在用 `ListMol3D` 链表接口。

你选择的“过渡策略”是：**在启用 simple 的那个 list 上，新增分子时直接写进 pool**。

在 [micro_molecule.c:L316-L325](file:///Users/faner/Documents/AcCoRD-master/src/micro_molecule.c#L316-L325)：

```c
if(gSoaSimpleEnabled && ... && p_list == gSoaSimpleList) {
  pool_add_molecule(gSoaSimplePool, x, y, z, true);
  return true;
}
return addItem(new_molecule, p_list);
```

这意味着：
- simple 目标 `(region,type)` 的“主存储”逐步变成 pool；
- 其他 `(region,type)` 仍保持链表不动；
- 这是一种典型的“逐步替换”工程打法。

---

### 3.7 观测性能改造：把“位置链表”改成 “位置数组”

第一轮性能改造不只在“分子扩散存储”，你还改了“观测输出”的数据结构。原因是：被动 Actor 记录位置时，原本要把位置再塞回链表，链表复制/遍历会变成额外成本。

#### 3.7.1 observation item 从 `ListMol3D**` 改为 `double**`

在 [observations.h:L37-L45](file:///Users/faner/Documents/AcCoRD-master/src/observations.h#L37-L45)，你把：
- `ListMol3D ** molPos`

改成：
- `double ** molPosX`
- `double ** molPosY`
- `double ** molPosZ`

这意味着“每次 observation”不再持有链表，而是持有三段连续数组。

#### 3.7.2 `addObservation` 的拷贝策略（`src/observations.c`）

在 [observations.c:L40-L122](file:///Users/faner/Documents/AcCoRD-master/src/observations.c#L40-L122)：
- 先为每个 molecule type 分配 `molPosX/Y/Z` 指针数组（长度 = `numMolTypeObs`）
- 对每个 type：
  - `count = paramUllongNew[curMolInd]`（这个 count 就是该次观测记录到的分子数）
  - 分配 `count` 长度的 `x/y/z` 数组
  - 遍历输入的链表 `molPosList`，把坐标写进数组

**为什么用 `paramUllong` 作为长度来源**
- upstream 里 `paramUllong[curMolInd]` 本来就记录 “该次观测到多少分子”
- 你用它来决定数组大小，实现“精确分配”，避免链表节点 per-molecule 的 malloc 开销。

#### 3.7.3 `emptyListObs` 的释放路径（`src/observations.c`）

在 [observations.c:L195-L219](file:///Users/faner/Documents/AcCoRD-master/src/observations.c#L195-L219)：
- 对每个 type，释放 `molPosX/Y/Z[curMolInd]`
- 最后释放 `molPosX/Y/Z` 三个指针数组

---

### 3.8 输出层适配：`printOneTextRealization` 如何打印位置数组

观测结构变了，输出也要变。你在 [file_io.c:L3074-L3102](file:///Users/faner/Documents/AcCoRD-master/src/file_io.c#L3074-L3102) 把打印逻辑从“遍历链表节点”改成：
- 如果 `molPosX/Y/Z` 非空：
  - 循环 `curPos = 0..count-1`
  - 输出 `(x[curPos], y[curPos], z[curPos])`

这一段是学生最常问的：“为什么 output 里 Position 的格式变成了数组打印？”——答案就在这里。

---

### 3.9 被动 Actor 在 SoA-simple 下如何观测：`recordMoleculesPool`

你让被动 Actor 在观测微观 region 时，优先从 pool 里扫描，而不是从链表扫描。

#### 3.9.1 pool 版计数/记录函数（`src/micro_molecule.c`）

在 [micro_molecule.c:L2838-L2888](file:///Users/faner/Documents/AcCoRD-master/src/micro_molecule.c#L2838-L2888)：
- `countMoleculesPool(...)`：只计数
- `recordMoleculesPool(...)`：计数 +（可选）把符合条件的分子坐标加入 `recordList`

它们通过构造一个临时 `ItemMol3D item`，复用 upstream 的 `isMoleculeObserved(...)` 做几何判断（[micro_molecule.c:L2849-L2855](file:///Users/faner/Documents/AcCoRD-master/src/micro_molecule.c#L2849-L2855)）。

#### 3.9.2 `accord.c` 的调用点（被动观测）

在 [accord.c:L670-L689](file:///Users/faner/Documents/AcCoRD-master/src/accord.c#L670-L689)，被动 Actor 对每个 region 做观测时：
- 如果 `gSoaSimpleEnabled` 且当前 list 是 `gSoaSimpleList`，就调用 `recordMoleculesPool(...)`
- 否则走原路径 `recordMolecules(...)`

这实现了“同一个观测逻辑，在不同数据布局下切换底层扫描方法”。

---

### 3.10 RNG 性能补丁：`generateNormalArray`

你在 [rand_accord.c:L86-L118](file:///Users/faner/Documents/AcCoRD-master/src/rand_accord.c#L86-L118) 增加了批量高斯生成：
- 每次循环用一次 Box-Muller 产生 2 个正态数，写入 `out[i]` 和 `out[i+1]`
- 这样避免了 `generateNormal` 里“static 缓存第二个值”的分支逻辑频繁干扰 pipeline
- 并且支持一次性生成 `pool->count` 个增量

声明在 [rand_accord.h:L52-L55](file:///Users/faner/Documents/AcCoRD-master/src/rand_accord.h#L52-L55)。

它在 SoA-simple 扩散内核里直接被使用（[micro_molecule.c:L222-L233](file:///Users/faner/Documents/AcCoRD-master/src/micro_molecule.c#L222-L233)）。

---

### 3.11 benchmark 与论文：你怎么证明“它确实更快”

#### 3.11.1 基准程序（`benchmark_test.c`）

你写了一个独立 benchmark： [benchmark_test.c](file:///Users/faner/Documents/AcCoRD-master/benchmark_test.c)

它包含两段对比：
1. **纯算术更新**（链表 vs SoA 数组）——隔离“内存布局”影响（[benchmark_test.c:L32-L105](file:///Users/faner/Documents/AcCoRD-master/benchmark_test.c#L32-L105)）
2. **接近真实扩散**（使用 AcCoRD 的 RNG 与 `MicroMoleculePool` 接口）——隔离“RNG 支配成本”现象（[benchmark_test.c:L155-L271](file:///Users/faner/Documents/AcCoRD-master/benchmark_test.c#L155-L271)）

#### 3.11.2 论文对齐（`research_paper.md`）

论文用实验分层解释：
- Synthetic benchmark 显示大约 3×（内存布局主导）
- Realistic benchmark 显示 5–6%（RNG 主导）

对应代码实现与数据结构设计在上面章节已经逐条映射到源代码文件。

---

## 4. 第二轮升级：依赖 Actor + AF（Amplify-and-Forward）转发

这一轮对应的“改动说明”在 [update.md](file:///Users/faner/Documents/AcCoRD-master/update.md)，代码改动主要集中在 actor/config/timer/accord 主循环上。

### 4.1 目标：让一个主动 Actor 的释放由另一个被动 Actor 的观测驱动

你实现的模型要点是：
- **依赖触发**：某个 passive actor 观察到的计数达到阈值（或累计增量达到阈值），触发 dependent active actor 行为；
- **AF 转发**：触发时释放强度 `strength` 不再只来自调制比特，而是来自观测值线性映射：
  - `strength = gain * obsValue + bias`
  - 并做 min/max clamp

---

### 4.2 数据结构：依赖/AF 参数存入 actor spec

你在 [actor.h:L127-L136](file:///Users/faner/Documents/AcCoRD-master/src/actor.h#L127-L136) 的 `actorStructSpec3D` 增加了字段：
- `dependentPassiveActorID`
- `dependentMolType`
- `dependentTriggerMode`
- `dependentTriggerValue`
- `bDependentRisingEdge`
- `dependentRelayMode`
- `dependentRelayGain`
- `dependentRelayBias`
- `dependentRelayMinStrength`
- `dependentRelayMaxStrength`

这些字段是“配置期（JSON）→ 运行期（仿真循环）”的主通道：所有 AF 行为都从这里取参数。

---

### 4.3 运行态：每个 active actor 需要记住“上一次观测值”

为了支持“上升沿触发”和“增量触发”，你在 [actor.h:L341-L343](file:///Users/faner/Documents/AcCoRD-master/src/actor.h#L341-L343) 的 `actorActiveStruct3D` 新增：
- `uint64_t depPrevCount;`
- `bool depPrevAbove;`

并在 `resetActors` 中初始化它们（[actor.c:L924-L953](file:///Users/faner/Documents/AcCoRD-master/src/actor.c#L924-L953)）。

**为什么放在 actorActiveStruct3D**
- `actorStruct3D`（common）是“跨重复/跨运行的通用 actor 信息”，但 `depPrevCount` 这种状态是“仿真过程中随时间变化的状态”，属于 active 的运行态字段；
- 这样每个 active actor 都能独立维护它自己的“上一时刻观测”。

---

### 4.4 新的释放路径：`newReleaseWithStrength`

AF 模式需要“强度覆盖”，因此你新增了 [actor.c:L1216-L1277](file:///Users/faner/Documents/AcCoRD-master/src/actor.c#L1216-L1277)：

- `newReleaseWithStrength(actorCommon, actorActive, curTime, strengthOverride)`

它与 `newRelease(...)` 的关键差异是：
- `newRelease(...)`：强度来自“调制比特 → binaryToDecimal → modStrength”
- `newReleaseWithStrength(...)`：强度直接取 `strengthOverride`

但它仍然复用 upstream 的 release/emission 管线：
- 生成一次 release interval
- `addRelease(...)` 进入 `releaseList`
- 调用 `findNextEmission(...)` 推进下一次 emission（[actor.c:L1273-L1274](file:///Users/faner/Documents/AcCoRD-master/src/actor.c#L1273-L1274)）

---

### 4.5 触发位置：被动 Actor 完成一次观测后，立刻扫描依赖主动 Actor

依赖 actor 的触发逻辑放在 `accord.c` 的“被动 Actor 事件分支”内部，也就是在完成一次观测后立即执行。

触发主循环位置见 [accord.c:L772-L947](file:///Users/faner/Documents/AcCoRD-master/src/accord.c#L772-L947)。

#### 4.5.1 先筛选哪些 active actor 依赖当前 passive actor

筛选条件（学生要会读）包括：
- actor 是 dependent（`!bIndependent`）
- actor 是 active
- `dependentPassiveActorID == heapTimer[0]`（当前触发的 passive actor id）
- 当前时间超过 dependent actor 的 start time
- 未超过 max action

这些筛选把“所有 active actor”缩小成“需要被这次观测驱动的那一小撮 actor”。

#### 4.5.2 trigger mode：阈值/增量/上升沿

触发逻辑分支：

- `dependentTriggerMode == 1`：增量触发
  - `depCount >= prevCount + dependentTriggerValue`
  - 触发后更新 `depPrevCount`（[accord.c:L805-L851](file:///Users/faner/Documents/AcCoRD-master/src/accord.c#L805-L851)）

- 否则（默认 mode 0）：阈值触发
  - `depAbove = depCount >= dependentTriggerValue`
  - 若 `bDependentRisingEdge`：只在 `depAbove` 从 false→true 时触发（[accord.c:L853-L899](file:///Users/faner/Documents/AcCoRD-master/src/accord.c#L853-L899)）
  - 否则：只要 `depAbove` 就触发（[accord.c:L900-L943](file:///Users/faner/Documents/AcCoRD-master/src/accord.c#L900-L943)）

并维护：
- `depPrevAbove`
- `depPrevCount`

#### 4.5.3 relay mode：是否 AF 映射

当触发发生时：
- 如果 `dependentRelayMode == 0`：走旧路径 `newRelease(...)`
- 否则：计算 `obsValue` 和 `strength`，并调用 `newReleaseWithStrength(...)`

强度计算点在 [accord.c:L819-L842](file:///Users/faner/Documents/AcCoRD-master/src/accord.c#L819-L842)（以及后面两个分支的同构代码）。

映射公式（实现语义）：
- mode 1：`obsValue = depCount`
- mode 2：`obsValue = depCount - prevCount`（允许负）
- `strength = gain * obsValue + bias`
- clamp 到 `[minStrength, maxStrength]`

---

### 4.6 为什么要“立刻 heapTimerUpdate”：修复事件调度一致性

依赖 actor 触发后，你会更新：
- `timerArray[depActorID].nextTime = actorActiveArray[curActive].nextEmissionTime;`
- `actorCommonArray[depActorID].nextTime = timerArray[depActorID].nextTime;`

接下来必须调用 `heapTimerUpdate(...)`，否则 timer heap 里“最早事件”的排序不会反映你刚才的更新。

你在每次触发分支末尾都做了：

```c
heapTimerUpdate(NUM_TIMERS, timerArray, heapTimer,
  timerArray[depActorID].heapID, heapTimerChildID, b_heapTimerChildValid);
```

代码位置见 [accord.c:L845-L848](file:///Users/faner/Documents/AcCoRD-master/src/accord.c#L845-L848)（以及其它分支对应位置）。

---

### 4.7 配置解析：让 JSON 能读进这些新字段（`src/file_io.c`）

你在 [file_io.c:L2085-L2219](file:///Users/faner/Documents/AcCoRD-master/src/file_io.c#L2085-L2219) 做了两类工作：

1. **设置默认值**（防止配置未提供时出现未初始化）
2. **当 actor 为 dependent active 时，读取 Dependent* 字段并做合法性检查**

同时，当 actor 是独立 active 时，如果配置里仍写了 Dependent* 字段，会打印 warning 并忽略（[file_io.c:L2220-L2272](file:///Users/faner/Documents/AcCoRD-master/src/file_io.c#L2220-L2272)）。

---

### 4.8 样例配置：把 AF 参数写进 `config/accord_config_sample.txt`

你在 [accord_config_sample.txt:L73-L100](file:///Users/faner/Documents/AcCoRD-master/config/accord_config_sample.txt#L73-L100) 给第三个 actor（dependent active）补上：
- `Dependent Passive Actor ID`
- `Dependent Molecule Type`
- `Dependent Trigger Mode/Value`
- `Dependent Relay Mode/Gain/Bias/Min/Max`

这份配置是学生做“功能验证”的最小例子：跑起来就能看到计数从 2 变 4（一次 dependent release 的效果）。

---

### 4.9 timer 更新语义：`updateTimer` 的最小职责（`src/timer_accord.c`）

你把 `updateTimer` 收敛为“只负责写 nextTime”：

见 [timer_accord.c:L121-L130](file:///Users/faner/Documents/AcCoRD-master/src/timer_accord.c#L121-L130)。

这与 `accord.c` 里显式调用 `heapTimerUpdate` 的策略配套：
- **谁改了 timer 的 nextTime，谁就负责立刻更新 heap**
- 避免出现“值改了，堆没改”的隐蔽 bug

---

### 4.10 跨平台：Windows 专用 `<direct.h>` 必须条件包含

在 Windows 下创建目录可能用 `_mkdir`，需要 `<direct.h>`；但 macOS 没有它。

你在 [file_io.h:L126-L128](file:///Users/faner/Documents/AcCoRD-master/src/file_io.h#L126-L128) 做了：

```c
#ifdef _WIN32
  #include <direct.h>
#endif
```

这保证了同一套代码在 macOS/Windows 都能编译。

---

## 5. 教学配套与“非核心但你确实动过”的文件

这一章回答学生常见的“这些文件是干嘛的？为什么会出现在工程里？”并解释你对它们做过的改动。

### 5.1 `QUESTIONS_QA.md` / `questions.txt`

- [QUESTIONS_QA.md](file:///Users/faner/Documents/AcCoRD-master/QUESTIONS_QA.md)：你整理的问答集（面向“学生问什么就答什么”）
- [questions.txt](file:///Users/faner/Documents/AcCoRD-master/questions.txt)：问题素材/草稿

它们的定位是“结果导向”：回答概念与使用问题，但不保证学生能顺着代码读懂“实现细节”。本文件（工程改动全解）就是为了解决这个 gap。

### 5.2 自动化脚本：一次跑完示例配置

- [run_all_samples.bat](file:///Users/faner/Documents/AcCoRD-master/run_all_samples.bat)：Windows 批处理版本
- [run_all_samples.ps1](file:///Users/faner/Documents/AcCoRD-master/run_all_samples.ps1)：PowerShell 版本（更强）

作用是：把 `config/` 里多个 sample 配置自动跑一遍，便于回归验证与教学演示。

### 5.3 benchmark 相关

- [benchmark_test.c](file:///Users/faner/Documents/AcCoRD-master/benchmark_test.c)：你写的基准对比程序
- `benchmark_test`、`bin/benchmark_test`：对应编译产物（二进制）
- [benchmark_summary.txt](file:///Users/faner/Documents/AcCoRD-master/benchmark_summary.txt)：结果汇总

### 5.4 两份“论文式说明”

- [research_paper.md](file:///Users/faner/Documents/AcCoRD-master/research_paper.md)：第一轮性能改造的论文式说明
- [update.md](file:///Users/faner/Documents/AcCoRD-master/update.md)：第二轮升级（依赖 Actor + AF）的论文式更新报告

（仓库里还有 `research_paper copy.md`、`update copy.md`，属于备份/拷贝稿，不影响代码执行。）

### 5.5 可执行文件与为什么它们会带来 push 问题

`bin/` 下包括：
- `accord_dub.out` / `accord_dub_debug.out` / `accord_win.exe` 等（编译产物）

这些文件对于“教学交付”确实方便，但它们是二进制大文件：
- 会让仓库体积膨胀
- 容易触发 GitHub push 的网络中断或配额问题

如果未来要规范化交付，建议把二进制放到 GitHub Releases 或 Git LFS，而不是直接提交进 git（这里先解释，不对仓库做额外改动）。

### 5.6 `.gitignore`

你在 [.gitignore](file:///Users/faner/Documents/AcCoRD-master/.gitignore) 里增加/调整了若干忽略项（例如 `mingw64.zip`），目的是避免把大型工具包或生成物误提交。

### 5.7 `.DS_Store`、PDF

`.DS_Store` 是 macOS Finder 产生的文件，不属于工程逻辑；两个 PDF（[1003.2845v1.pdf](file:///Users/faner/Documents/AcCoRD-master/1003.2845v1.pdf)、[1716_1_online.pdf](file:///Users/faner/Documents/AcCoRD-master/1716_1_online.pdf)）是资料/参考阅读，不影响编译与运行。

---

## 6. 最重要的“模块责任划分”（学生问：哪个部门负责啥？）

把你改动涉及的模块按职责划分如下：

- **仿真调度与总控（Simulation Driver）**：[accord.c](file:///Users/faner/Documents/AcCoRD-master/src/accord.c)
  - 负责：读配置→初始化→主循环（heap 驱动事件）→输出→释放
  - 你新增：SoA-simple 启用条件、pool 观测路径、dependent actor 触发与 AF 映射

- **微观分子与扩散（Micro Molecules）**：[micro_molecule.c](file:///Users/faner/Documents/AcCoRD-master/src/micro_molecule.c)、[micro_molecule.h](file:///Users/faner/Documents/AcCoRD-master/src/micro_molecule.h)
  - 负责：分子链表管理、扩散/流动、跨 region/meso 迁移、观测辅助
  - 你新增：MicroMoleculePool（SoA）、SoA-simple 扩散内核、pool 观测扫描

- **Region 生命周期（Regions）**：[region.c](file:///Users/faner/Documents/AcCoRD-master/src/region.c)、[region.h](file:///Users/faner/Documents/AcCoRD-master/src/region.h)
  - 负责：region 初始化/验证/邻接/释放
  - 你新增：每个 micro region 持有一个 molPool，并在 init/free 管理其生命周期

- **随机数（RNG）**：[rand_accord.c](file:///Users/faner/Documents/AcCoRD-master/src/rand_accord.c)、[rand_accord.h](file:///Users/faner/Documents/AcCoRD-master/src/rand_accord.h)
  - 负责：uniform/normal/exponential/poisson
  - 你新增：批量 normal 数组生成 `generateNormalArray`

- **观测存储（Observations）**：[observations.c](file:///Users/faner/Documents/AcCoRD-master/src/observations.c)、[observations.h](file:///Users/faner/Documents/AcCoRD-master/src/observations.h)
  - 负责：把每次观测的计数/时间/位置存入链表，供输出层消费
  - 你改造：位置从链表改为三数组（X/Y/Z），减少链表复制/遍历成本

- **Actor 行为（Actors）**：[actor.c](file:///Users/faner/Documents/AcCoRD-master/src/actor.c)、[actor.h](file:///Users/faner/Documents/AcCoRD-master/src/actor.h)
  - 负责：active 的 release/emission 管线、passive 的观测参数
  - 你新增：dependent actor 状态字段、按强度覆盖的 `newReleaseWithStrength`

- **配置与输出（I/O）**：[file_io.c](file:///Users/faner/Documents/AcCoRD-master/src/file_io.c)、[file_io.h](file:///Users/faner/Documents/AcCoRD-master/src/file_io.h)
  - 负责：解析 JSON 配置、生成输出文件、打印 observation
  - 你新增：dependent actor 配置解析；输出层适配新的 observation 位置数组；跨平台包含修复

- **事件定时器与堆（Timers / Heap）**：[timer_accord.c](file:///Users/faner/Documents/AcCoRD-master/src/timer_accord.c)
  - 负责：管理 nextTime、维护 heap 有序性
  - 你修复/强调：更新 nextTime 后必须立即 heapTimerUpdate

---

## 7. 下一步（如果学生还看不懂，怎么用这份文档答疑）

当学生卡住时，你可以按“定位问题 → 指到函数 → 指到调用点”的方式答：
- “它在哪改的？”→ 本文的 **文件+行号链接**
- “为什么要这么改？”→ 每节的 **Why** 段落
- “运行时到底发生了什么？”→ 看第 2 章主循环 + 第 3/4 章的插入点

---

## 8. 逐行级“洗代码”讲解（只覆盖你改动/新增的代码块）

这一章专门解决你说的“还是不够细”。做法是：
- **只解释你改动过的地方**（也就是 diff 里新增/修改/删除的代码块），不把 upstream 没动过的几千行重复一遍；
- 对每个改动块，几乎按“每一行代码 → 它做了什么 → 为什么要这样写 → 和谁配合”的粒度解释；
- 每个小节都给出“可点击的行号范围”，学生可以对着看源码。

如果学生问“那这行代码里某个变量又从哪来？”——你就顺着链接点进去继续追（本文也会给出上游来源的入口函数名）。

---

## 9. 第一轮性能升级（SoA / Pool）逐行讲解

### 9.1 `src/micro_molecule.h`：新增 SoA 数据结构与 pool_* 操作

代码位置：[micro_molecule.h:L130-L263](file:///Users/faner/Documents/AcCoRD-master/src/micro_molecule.h#L130-L263)

#### 9.1.1 `struct MicroMoleculePool`（SoA 存储）

对应代码：[micro_molecule.h:L143-L152](file:///Users/faner/Documents/AcCoRD-master/src/micro_molecule.h#L143-L152)

逐行解释：
- `struct MicroMoleculePool {`：定义一个“分子池”，它不是链表节点，而是“多个数组 + 计数器”的容器。
- `double* x; / y; / z;`：三个连续数组，分别存所有分子的 x/y/z 坐标；这就是 SoA 的核心（同类数据紧挨着，cache 友好）。
- `bool* bNeedUpdate;`：把 upstream 每个分子节点里的 `bNeedUpdate` 也变成数组，保持原语义（“这个分子本 micro step 是否还需要处理”）。
- `size_t count;`：当前池中有效分子数量，相当于 `vector.size()`。
- `size_t capacity;`：数组当前容量，控制是否需要扩容。
- `};`：结构结束。

为什么这样写：
- upstream 链表的瓶颈在“指针追逐 + 节点分散”，SoA 用连续数组让遍历变成顺序访问；
- `count/capacity` 是动态数组的最小元信息，配合 `realloc` 扩容。

#### 9.1.2 三个全局开关变量（SoA-simple 的“目标池/目标链表”）

对应代码：[micro_molecule.h:L175-L177](file:///Users/faner/Documents/AcCoRD-master/src/micro_molecule.h#L175-L177)

逐行解释：
- `extern bool gSoaSimpleEnabled;`：全局布尔开关，表示“是否启用 SoA-simple 这条路径”。
- `extern MicroMoleculePool* gSoaSimplePool;`：全局指针，指向“当前被 SoA-simple 接管的 region 的池”。
- `extern ListMol3D* gSoaSimpleList;`：全局指针，指向“与该 pool 对应的链表入口指针”，用于在现有链表 API 中定位“哪个 list 被接管”。

为什么需要 `gSoaSimpleList`：
- 你在过渡阶段让系统“pool 与链表共存”，很多函数仍然传 `ListMol3D* p_list`；
- 通过指针比较 `p_list == gSoaSimpleList`，你可以在不改所有函数签名的情况下，把“某一个 list 的新增分子”重定向到 pool。

#### 9.1.3 `pool_init`：初始化池（分配数组）

对应代码：[micro_molecule.h:L187-L202](file:///Users/faner/Documents/AcCoRD-master/src/micro_molecule.h#L187-L202)

逐行解释（按执行顺序）：
- `static inline void pool_init(...`：内联函数，减少调用开销；放在头文件是为了编译器跨单元优化。
- `if(initial_capacity < 1) initial_capacity = 1;`：防御式编程，避免 `malloc(0)` 的不确定行为。
- `pool->count = 0;`：初始化为空池。
- `pool->capacity = initial_capacity;`：记录容量。
- `pool->x = (double*)malloc(...);`：为 x 坐标分配一段连续内存。
- `pool->y = ...; pool->z = ...;`：同理分配 y/z。
- `pool->bNeedUpdate = (bool*)malloc(...);`：分配标记数组。
- `if(!pool->x || !pool->y || ... ) { fprintf...; exit...; }`：任何一次分配失败就直接终止程序；这里沿用了 AcCoRD 的风格（内存不足属于不可恢复错误）。

#### 9.1.4 `pool_add_molecule`：追加一个分子（含扩容）

对应代码：[micro_molecule.h:L204-L230](file:///Users/faner/Documents/AcCoRD-master/src/micro_molecule.h#L204-L230)

逐行解释：
- `if(pool->count >= pool->capacity)`：判断是否已满。
- `size_t new_capacity = pool->capacity * 2;`：容量翻倍，这是动态数组常用策略（摊还 O(1)）。
- `realloc(...)`：分别对 x/y/z/bNeedUpdate 四个数组扩容；保持索引对齐（同一个分子永远用同一个 idx 访问四个数组）。
- `if(!new_x || !new_y || ... ) exit`：任何一个 reallocate 失败就终止（同上）。
- `pool->x = new_x; ... pool->capacity = new_capacity;`：把新指针写回池结构，更新容量。
- `size_t idx = pool->count;`：新分子的下标就是当前 count（尾插）。
- `pool->x[idx] = x; ...`：写入坐标与标志位。
- `pool->count++;`：池大小 +1。

#### 9.1.5 `pool_remove_molecule`：O(1) 删除（swap-and-pop）

对应代码：[micro_molecule.h:L232-L245](file:///Users/faner/Documents/AcCoRD-master/src/micro_molecule.h#L232-L245)

逐行解释：
- `if(index >= pool->count) return;`：非法 index 直接返回，避免越界。
- `size_t last_idx = pool->count - 1;`：最后一个元素下标。
- `if(index != last_idx) { pool->x[index] = pool->x[last_idx]; ... }`：把最后一个分子搬到被删除的位置，保持数组紧凑。
- `pool->count--;`：逻辑删除最后一个元素（原最后一个位置的数据已被搬走或不再可达）。

为什么选择 swap-and-pop：
- 它让删除变成常数时间；
- 分子集合本来无序，不需要保持 insertion order。

#### 9.1.6 `pool_free`：释放池持有的数组

对应代码：[micro_molecule.h:L247-L263](file:///Users/faner/Documents/AcCoRD-master/src/micro_molecule.h#L247-L263)

逐行解释：
- `if(pool->x) free(pool->x);`：逐个释放，避免对 NULL free（虽然 free(NULL) 合法，但这里更显式）。
- 最后把指针置 NULL、`count/capacity` 清零：防止 double-free 或悬挂指针被误用。

---

### 9.2 `src/region.h` + `src/region.c`：让每个微观 Region 拥有自己的池

#### 9.2.1 `region.h`：新增 `molPool` 字段

对应代码：[region.h:L182-L185](file:///Users/faner/Documents/AcCoRD-master/src/region.h#L182-L185) 与 [region.h:L576-L579](file:///Users/faner/Documents/AcCoRD-master/src/region.h#L576-L579)

逐行解释：
- `struct MicroMoleculePool;`：前置声明，避免 `region.h` 直接 include `micro_molecule.h` 造成循环依赖。
- `struct MicroMoleculePool * molPool;`：每个 region 持有一个指向 pool 的指针；只有微观 region 会分配它，介观 region 为 NULL。

为什么放在 `struct region`：
- region 是分子“归属”的自然边界；
- pool 的创建/销毁与 region 生命周期一致，内存管理更清晰。

#### 9.2.2 `region.c`：初始化时分配 pool

对应代码：[region.c:L306-L321](file:///Users/faner/Documents/AcCoRD-master/src/region.c#L306-L321)

逐行解释：
- `for(i = 0; i < NUM_REGIONS; i++)`：遍历所有 region。
- `if(subvol_spec[i].bMicro)`：只给微观 region 分配 pool。
- `malloc(sizeof(struct MicroMoleculePool))`：为 pool 结构体本身分配内存。
- `if(regionArray[i].molPool == NULL) exit`：分配失败直接终止。
- `pool_init(regionArray[i].molPool, 1000);`：初始化 pool 的内部数组，初始容量 1000。
- `else regionArray[i].molPool = NULL;`：非微观 region 明确置空。

为什么初始容量是 1000：
- 原型阶段的固定默认值：保证小样例不频繁扩容；
- 真正工程化时可以根据预估初始分子数调整，但这不是你这一轮验证的重点。

#### 9.2.3 `region.c`：销毁时释放 pool

对应代码：[region.c:L628-L633](file:///Users/faner/Documents/AcCoRD-master/src/region.c#L628-L633)

逐行解释：
- `if(regionArray[i].molPool != NULL)`：仅当确实分配过才释放。
- `pool_free(regionArray[i].molPool);`：释放内部数组。
- `free(regionArray[i].molPool);`：释放 pool 结构体本身。
- `regionArray[i].molPool = NULL;`：避免悬挂指针。

为什么在 `delete_boundary_region_` 里做：
- upstream 把 region 释放集中在这里，你沿用集中释放策略，避免引入新的 teardown 路径导致泄露或重复释放。

---

### 9.3 `src/rand_accord.c/.h`：新增批量正态生成 `generateNormalArray`

对应代码：[rand_accord.c:L86-L118](file:///Users/faner/Documents/AcCoRD-master/src/rand_accord.c#L86-L118) 与 [rand_accord.h:L52-L55](file:///Users/faner/Documents/AcCoRD-master/src/rand_accord.h#L52-L55)

逐行解释（核心循环）：
- `void generateNormalArray(...)`：新 API，一次生成 `count` 个正态随机数写进 `out[]`。
- `if(count < 2)`：小数组直接调用单值版 `generateNormal` 处理，避免写复杂逻辑。
- `limit = count & ~(size_t)1;`：把 limit 取为不超过 count 的最大偶数（例如 7→6），因为 Box-Muller 一次产 2 个。
- `for(i = 0; i < limit; i += 2)`：每次循环生成一对值填入 `out[i]` 和 `out[i+1]`。
- `do { xVal = 2*U-1; yVal = 2*U-1; magnitude = xVal*xVal + yVal*yVal; } while(magnitude > 1.0 || magnitude == 0.)`：
  - 这是 Marsaglia polar form（Box-Muller 的一种实现）；
  - magnitude 是点在单位圆内的判定；
  - 避免 `magnitude==0` 防止除零。
- `offset = sqrt(-2.0*log(magnitude)/magnitude);`：极坐标变换得到正态缩放因子。
- `out[i] = mean + std * xVal * offset;`：写入第一个正态样本。
- `out[i+1] = mean + std * yVal * offset;`：写入第二个样本。
- `if(limit != count) out[count-1] = generateNormal(mean, std);`：如果 count 是奇数，补最后一个。

为什么你需要它：
- SoA-simple 扩散要为所有分子一次性生成 dx/dy/dz；
- 单个 `generateNormal` 每次生成一个值会产生额外分支/函数开销；
- 批量 API 让调用点更清晰，也为未来向 SIMD RNG 或向量化 RNG 迁移提供接口。

---

### 9.4 `src/micro_molecule.c`：SoA-simple 受控扩散路径（逐行）

#### 9.4.1 三个全局变量定义

对应代码：[micro_molecule.c:L114-L116](file:///Users/faner/Documents/AcCoRD-master/src/micro_molecule.c#L114-L116)

逐行解释：
- `bool gSoaSimpleEnabled = false;`：默认不启用（保证不改变 upstream 默认行为）。
- `MicroMoleculePool* gSoaSimplePool = NULL;`：默认没有目标池。
- `ListMol3D* gSoaSimpleList = NULL;`：默认没有目标链表。

#### 9.4.2 `listToPoolSimple`：把链表拷贝进 pool（simple 版本）

对应代码：[micro_molecule.c:L136-L152](file:///Users/faner/Documents/AcCoRD-master/src/micro_molecule.c#L136-L152)

逐行解释：
- `NodeMol3D* node;`：遍历链表节点的游标。
- `if(pool == NULL) return;`：防御：没池就不用拷贝。
- `pool->count = 0;`：重置池长度，表示“覆盖写入”（不是追加）。
- `node = list;`：从链表头开始。
- `while(node != NULL)`：逐节点遍历。
- `pool_add_molecule(pool, node->item.x, node->item.y, node->item.z, true);`：
  - 把链表节点中的坐标复制进 pool；
  - `bNeedUpdate` 统一置为 true，表示在本 micro step 中需要处理。
- `node = node->next;`：前进到下一个节点。

为什么你写了它但 simple 路径暂时没调用它：
- 你最初的设计是 “list ↔ pool 来回同步”，后来为了最小闭环，你改成了“某个 list 被 pool 接管，新分子直接进 pool”，所以这两个函数更多是“早期原型遗留/备用”。

#### 9.4.3 `poolToListSimple`：把 pool 坐标写回链表

对应代码：[micro_molecule.c:L154-L170](file:///Users/faner/Documents/AcCoRD-master/src/micro_molecule.c#L154-L170)

逐行解释：
- `NodeMol3D* node; size_t i;`：node 遍历链表，i 遍历 pool 数组。
- `if(pool == NULL) return;`：防御。
- `node = list; i = 0;`：初始化。
- `while(node != NULL && i < pool->count)`：同步写回，直到链表结束或 pool 写完。
- `node->item.x = pool->x[i]; ...`：写回三坐标。
- `i++; node = node->next;`：推进。

#### 9.4.4 `diffuseMolecules_pool_simple`：SoA 形式的扩散+流动+几何校验

对应代码：[micro_molecule.c:L172-L312](file:///Users/faner/Documents/AcCoRD-master/src/micro_molecule.c#L172-L312)

这里按“关键语句块”逐行解释（学生需要对照源文件逐句看）：

**(A) 函数签名与参数意义**
- `const short NUM_REGIONS, const unsigned short NUM_MOL_TYPES`：用于调用 `validateMolecule` 等需要知道系统规模的函数。
- `MicroMoleculePool* pool`：目标分子池（SoA）。
- `short curRegion, unsigned short curType`：当前处理的 region 与 molecule type。
- `const struct region regionArray[]`：提供扩散/流动/边界等物理参数与几何信息。
- `double sigma[NUM_REGIONS][NUM_MOL_TYPES]`：每个 `(region,type)` 的扩散标准差（上游 `sqrt(2 D dt)`）。
- `const struct chem_rxn_struct chem_rxn[]`：给 `validateMolecule` 用（即便 simple 模式要求无反应，也要传入）。
- `double DIFF_COEF[NUM_REGIONS][NUM_MOL_TYPES]`：同上。

**(B) 立即丢弃的参数**
- `(void)NUM_MOL_TYPES; (void)mesoSubArray; (void)HYBRID_DIST_MAX;`：
  - 这个函数签名保持与未来扩展兼容；
  - simple 模式明确“不支持 meso/hybrid”，所以这里暂时不用这些参数，用 `(void)` 避免编译器警告。

**(C) 早退出**
- `if(pool == NULL) return;`：没有 pool 就没法做。
- `if(pool->count == 0) return;`：没有分子就不用扩散。
- `if(!regionArray[curRegion].bDiffuse[curType] && !regionArray[curRegion].spec.bFlow[curType]) return;`：
  - 如果这个类型既不扩散也不流动，那么坐标不会变化，直接返回。

**(D) 批量生成扩散增量 dx/dy/dz**
- `dx = NULL; dy = NULL; dz = NULL;`：初始化指针，便于后面 `free`。
- `if(regionArray[curRegion].bDiffuse[curType])`：
  - 只有允许扩散时才生成随机增量；
  - 这保持与 upstream 语义一致（有些 type 可能 D=0 或被禁用扩散）。
- `dx = malloc(pool->count * sizeof(double));`（y/z 同理）：
  - 为每个分子分配一个增量；
  - 这是 SoA 方案里的典型“两阶段”策略：先生成数据，再做纯加法循环。
- `if(dx == NULL || ...) exit`：内存不足是不可恢复错误。
- 三次调用 `generateNormalArray(0.0, sigma[curRegion][curType], d?, pool->count);`：
  - 均值 0、标准差 sigma；
  - 分别生成 x/y/z 方向的布朗增量。

**(E) 对每个分子做：坐标更新 → validateMolecule → 写回/回滚**
- `for(i = 0; i < pool->count; i++)`：顺序访问，cache 友好。
- `oldPoint[...] = pool->x/y/z[i];`：读出旧位置。
- `newPoint = oldPoint;`：初始化新位置为旧位置（便于只在需要时叠加）。
- 如果扩散开启：`newPoint += d?`（对应 dx[i]/dy[i]/dz[i]）。
- 如果流动开启：根据 `flowType` 叠加 `flowConstant`；目前只处理 `FLOW_UNIFORM`（与 upstream 已有逻辑一致）。
- 初始化一堆用于 `validateMolecule` 的状态变量：
  - `bPointChange/bReaction/bApmcCur`：由 validateMolecule 输出，表示是否发生反射/反应等；
  - `newRegion/transRegion/curRxn`：validateMolecule 的输出，用来告诉你是否跨 region 或发生反应。
- 调用 `validateMolecule(...)`：
  - 这是你非常关键的选择：**不自己写几何碰撞/反射逻辑**，而是复用 upstream 已验证过的路径跟踪与反射判断；
  - 所以 SoA-simple 的“物理正确性”依赖于 upstream 的 validateMolecule。
- `if(!bValidDiffusion) { pool->x[i]=oldPoint...; continue; }`：
  - validateMolecule 返回 false 表示这次移动不合法；
  - simple 模式的策略是“回滚到旧位置”，然后处理下一个分子。
- `if(newRegion != curRegion || !regionArray[newRegion].spec.bMicro) { fprintf...; exit; }`：
  - 这是 simple 模式的硬约束：不允许跨 region；
  - 一旦跨了，说明配置不满足 simple 模式前提，你选择直接报错终止，避免悄悄产生不一致结果。
- 否则写回 `pool->x/y/z[i] = newPoint[...]`。

**(F) 收尾释放增量数组**
- 只要 `dx/dy/dz` 非 NULL 就 free；
- 如果本轮没有扩散（只有 flow），dx/dy/dz 会保持 NULL，free 也不会发生。

#### 9.4.5 `addMolecule`：在 SoA-simple 模式下把“新增分子”导向 pool

对应代码：[micro_molecule.c:L316-L325](file:///Users/faner/Documents/AcCoRD-master/src/micro_molecule.c#L316-L325)

逐行解释：
- `ItemMol3D new_molecule = {x,y,z, true};`：构造一个链表节点使用的分子 item（为了兼容旧路径）。
- `if(gSoaSimpleEnabled && ... && p_list == gSoaSimpleList)`：
  - 只有启用 simple 且目标 pool/list 有效，并且“调用方传进来的 list 就是目标 list”才走 pool。
- `pool_add_molecule(gSoaSimplePool, x, y, z, true);`：直接把分子写进 pool，不再创建链表节点。
- `return true;`：告诉调用方“成功添加”。
- `return addItem(new_molecule, p_list);`：非目标 list 仍按 upstream 链表方式 malloc 节点并插入。

这行最重要的工程意义：
- 它是你“逐步替换链表为 pool”的第一根楔子；
- 不需要全工程改签名，就能让某个 list 的新增分子不再落地到链表。

#### 9.4.6 `diffuseMolecules`：在主扩散循环里跳过 SoA-simple 目标并调用 pool 内核

对应代码：[micro_molecule.c:L350-L460](file:///Users/faner/Documents/AcCoRD-master/src/micro_molecule.c#L350-L460)

关键行解释：
- `bool bSoaSimpleGlobal; short soaRegion; unsigned short soaType;`：
  - `soaRegion/soaType` 用于标识“哪个 (region,type) 是 simple 目标”；
  - `bSoaSimpleGlobal` 表示是否通过了所有 guard 条件并正式启用。
- `if(gSoaSimpleEnabled && gSoaSimplePool != NULL && gSoaSimpleList != NULL)`：只有当 `accord.c` 已设置好目标，才继续。
- 第一段双重循环：在 `p_list` 二维数组里找到 `&p_list[curRegion][curType] == gSoaSimpleList` 的那一项，并记录 `soaRegion/soaType`。
- guard 条件串（`numChemRxn==0`、`!bHasMesoNeigh`、`HYBRID_DIST_MAX<=0`、`surfaceType==NO_SURFACE`、`numApmcRxn==0` 等）：
  - 目的就是保证“simple 内核不会遇到跨 region/反应/meso/hybrid”。
- 之后的“标记 bNeedUpdate”循环里，你显式跳过 simple 目标（`continue`），避免同一 micro step 被处理两次。
- 在真正扩散循环中：
  - 如果是 simple 目标 `(soaRegion,soaType)`：
    - `pool = regionArray[curRegion].molPool;`
    - 调 `diffuseMolecules_pool_simple(...)`
    - `continue;`
  - 其它的仍按 upstream 链表移动逻辑执行。

---

### 9.5 `src/observations.h/.c`：观测位置从“链表”改为 “三数组”（逐行）

#### 9.5.1 结构体字段变化（`observations.h`）

对应代码：[observations.h:L37-L45](file:///Users/faner/Documents/AcCoRD-master/src/observations.h#L37-L45)

逐行解释：
- `double ** molPosX; / molPosY; / molPosZ;`：
  - `molPosX[curMolInd]` 指向“该次观测下，第 curMolInd 个观测类型的所有分子的 X 坐标数组”；
  - Y/Z 同理；
  - 数组长度由 `paramUllong[curMolInd]` 给出（也就是这次观测记录到的分子数量）。

为什么要改：
- upstream 是 `ListMol3D ** molPos`，会在每次 observation 时构造链表节点，导致大量小 malloc；
- 你改成数组后，一次观测只需要 3 次大块 malloc（X/Y/Z），遍历和输出也更快。

#### 9.5.2 `addObservation`：把输入链表“拷贝成三数组”

对应代码：[observations.c:L40-L122](file:///Users/faner/Documents/AcCoRD-master/src/observations.c#L40-L122)

逐行解释（按块）：
- `double * paramDoubleNew = malloc(...); uint64_t * paramUllongNew = malloc(...);`：保持 upstream 行为，把这次 observation 的参数复制到新分配内存里（避免引用外部栈内存）。
- `double ** molPosXNew = malloc(numMolTypeObs * sizeof(double*));`（Y/Z 同理）：
  - 为每个“被记录的 molecule type”准备一个指针槽位；
  - 指针数组长度= `list->numMolTypeObs`。
- 初始化循环把每个 `molPosXNew[curMolInd]` 置 NULL：
  - 这样在某个类型没有记录位置时，不需要分配数组，释放也安全。
- 复制 `paramDouble`/`paramUllong`：
  - `paramUllongNew[curMolInd]` 里已经有“这次观测记录到多少分子”的计数。
- 拷贝坐标链表 → 坐标数组：
  - `molPosList = molPos[curMolInd];` 取到输入链表头；
  - `if(!isListMol3DEmpty(&molPos[curMolInd]))`：非空才处理；
  - `count = paramUllongNew[curMolInd];`：决定数组长度；
  - 分配 `count` 大小的 X/Y/Z 数组；
  - `while(molPosList != NULL)` 遍历链表，将 `molPosList->item.x/y/z` 写入数组；
  - `if(idx >= count) break;`：双保险，避免链表长度与计数不一致时越界。
- 最后组装 `ItemObs3D newObs3D;`：
  - 把 `numDouble/numUllong/paramDouble/paramUllong/molPosX/Y/Z` 都写进去；
  - 然后 `return addItem(newObs3D, list);` 插入 observation 链表。

#### 9.5.3 `emptyListObs`：释放三数组

对应代码：[observations.c:L195-L219](file:///Users/faner/Documents/AcCoRD-master/src/observations.c#L195-L219)

逐行解释：
- 对每个 observation node：
  - free `paramDouble/paramUllong`
  - 对每个 `curMolInd`：
    - free `molPosX[curMolInd]`、`molPosY[curMolInd]`、`molPosZ[curMolInd]`
  - free 三个指针数组本身 `molPosX/molPosY/molPosZ`
  - free node

---

### 9.6 `src/accord.c`：SoA-simple 的启用与观测接入（逐行）

#### 9.6.1 启用开关：环境变量 `ACCORD_USE_SOA_SIMPLE`

对应代码：[accord.c:L250-L307](file:///Users/faner/Documents/AcCoRD-master/src/accord.c#L250-L307)

逐行解释（核心逻辑）：
- `gSoaSimpleEnabled=false; gSoaSimplePool=NULL; gSoaSimpleList=NULL;`：每次启动都先清空开关，保证默认行为稳定。
- `const char* soaEnv = getenv("ACCORD_USE_SOA_SIMPLE");`：
  - 你用环境变量控制开关；
  - 好处是：不用改 JSON 配置格式，也不用改命令行参数解析，最小入侵。
- `if(soaEnv != NULL)`：只要设置了该环境变量就尝试启用（值内容不重要）。
- 扫描 `regionArray` 的所有 region：
  - 一系列 `continue` 过滤（必须是 micro、无反应、无 meso 邻居、有 pool、非 surface）；
  - 再扫描 molecule type：
    - 必须无 APMC；
    - 必须非 hybrid；
    - 保证全系统只能选出一个 `(region,type)`（否则 `soaRegion=-2` 表示冲突）。
- `if(soaRegion >= 0) { gSoaSimpleEnabled=true; gSoaSimplePool=...; gSoaSimpleList=...; }`
  - 只有确实找到唯一目标，才真正打开开关并设置目标指针。

#### 9.6.2 被动观测：优先从 pool 扫描（否则走链表）

对应代码：[accord.c:L670-L689](file:///Users/faner/Documents/AcCoRD-master/src/accord.c#L670-L689)

逐行解释：
- 这段处于“被动 actor 事件”中，对 actor 覆盖的每个 region 统计分子数并可选记录位置。
- 当 `regionArray[curRegion].spec.bMicro` 时：
  - 如果 `gSoaSimpleEnabled` 且该 region 有 pool 且 `&microMolList[curRegion][curMolType] == gSoaSimpleList`：
    - 用 `recordMoleculesPool(regionArray[curRegion].molPool, ...)` 扫描 pool；
    - 同时也扫描 recent list `recordMoleculesRecent(...)`（recent 仍是链表，因为它表示“刚生成但未转移到 normal list 的分子”）。
  - 否则：
    - 走 upstream 路径 `recordMolecules(&microMolList[curRegion][curMolType], ...)` + `recordMoleculesRecent(...)`。

为什么 recent list 没改为 pool：
- recent list 的语义是“在 micro step 内任意时刻生成的新分子”，它的生命周期与合并逻辑更复杂；
- 你这轮的目标是先把“normal list 的扩散遍历”打通 SoA，recent 的 SoA 化属于下一阶段工程。

---

## 10. 第二轮升级（依赖 Actor + AF）逐行讲解

### 10.1 `src/actor.h`：新增 dependent/AF 配置字段 + 运行态状态字段

#### 10.1.1 actor spec：把依赖与 AF 参数写进 `actorStructSpec3D`

对应代码：[actor.h:L127-L136](file:///Users/faner/Documents/AcCoRD-master/src/actor.h#L127-L136)

逐行解释：
- `short dependentPassiveActorID;`：这个 active actor 依赖哪个 passive actor（common actor id）。
- `unsigned short dependentMolType;`：从 passive actor 的观测里取哪一种分子类型计数。
- `unsigned short dependentTriggerMode;`：触发模式（你支持 0=阈值、1=增量阈值）。
- `uint64_t dependentTriggerValue;`：阈值数值（计数阈值或增量阈值）。
- `bool bDependentRisingEdge;`：是否只在“从未达阈到达阈”的上升沿触发。
- `unsigned short dependentRelayMode;`：转发模式（0=旧行为不映射、1=按绝对计数映射、2=按增量映射）。
- `double dependentRelayGain; / dependentRelayBias;`：AF 线性映射参数。
- `double dependentRelayMinStrength; / dependentRelayMaxStrength;`：对映射后的强度做 clamp，避免负值或过大值破坏模型/数值稳定。

#### 10.1.2 actor active 运行态：记录上一轮观测

对应代码：[actor.h:L341-L343](file:///Users/faner/Documents/AcCoRD-master/src/actor.h#L341-L343)

逐行解释：
- `uint64_t depPrevCount;`：上一次看到的计数（用于增量触发/增量映射）。
- `bool depPrevAbove;`：上一次是否“在阈值以上”（用于 rising edge）。

---

### 10.2 `src/actor.c`：初始化运行态 + 新增 `newReleaseWithStrength`

#### 10.2.1 `resetActors` 初始化 dependent 运行态字段

对应代码：[actor.c:L951-L952](file:///Users/faner/Documents/AcCoRD-master/src/actor.c#L951-L952)

逐行解释：
- `actorActiveArray[curActor].depPrevCount = 0ULL;`：初始计数为 0，表示“尚未观测到任何分子”。
- `actorActiveArray[curActor].depPrevAbove = false;`：初始不在阈值以上。

为什么要在 reset 里做：
- 每次 repeat（蒙特卡洛重复）都要把运行态清零；
- 依赖触发是运行态行为，不清零会导致跨重复串扰。

#### 10.2.2 `newReleaseWithStrength`：按外部指定强度生成 release

对应代码：[actor.c:L1216-L1277](file:///Users/faner/Documents/AcCoRD-master/src/actor.c#L1216-L1277)

逐行解释（按执行顺序）：
- `ListData newData;`：仍然维护 active actor 的 binaryData 链表（即便 AF 不靠比特推强度，也要保持数据结构一致以兼容输出/统计）。
- `for(i = 0; i < actorCommon->spec.modBits; i++) addData(&newData, true);`：
  - 在 AF 模式下，你用全 1 的 bit 序列作为“占位符”；
  - 目的是让 `binaryData` 的长度与符号间隔一致（否则某些输出/统计逻辑会失衡）。
- `transferData(&actorActive->binaryData, &newData);`：把新生成的 bits 挂到 actorActive 的数据链表上。
- `strength = strengthOverride;`：强度直接由外部输入（AF 映射结果）。
- `startTime=0; endTime=releaseInterval; frequency=0;`：复用 upstream 对 BURST/CSK release interval 的定义。
- `if(strength > 0. && actorCommon->spec.bTimeReleaseRand) startTime = generateExponential(1)/strength;`：
  - 如果 emission 时间是随机的，那么第一发射时间服从指数分布；
  - 仍然沿用 upstream 的“强度影响 emission 间隔”的建模。
- `if(strength > 0.) { switch(modScheme) ... addRelease(...); findNextEmission(...); }`：
  - 强度不为 0 才真正创建 release；
  - BURST 可能对多个 molType 同时释放，所以循环 addRelease；
  - 最后 `findNextEmission` 更新 `nextEmissionTime`，让 timer 能驱动后续 emission。

---

### 10.3 `src/file_io.c`：解析 dependent/AF 参数 + 输出适配位置数组

#### 10.3.1 在读取每个 actor 时先初始化 dependent/AF 默认值

对应代码：[file_io.c:L2085-L2094](file:///Users/faner/Documents/AcCoRD-master/src/file_io.c#L2085-L2094)

逐行解释：
- 这里的每一行都是“防止未初始化”的关键：
  - 如果用户配置文件没写 Dependent* 字段，你也要保证 spec 里是确定值；
  - 否则后续 `accord.c` 读这些字段会出现随机值导致不可预测行为。

#### 10.3.2 只有 dependent active 才读取 Dependent* 字段（否则 warning 并忽略）

对应代码主块：[file_io.c:L2107-L2272](file:///Users/faner/Documents/AcCoRD-master/src/file_io.c#L2107-L2272)

你做的结构是“两层门”：
- 第一层：`if(curSpec->actorSpec[curArrayItem].bActive)`：只有 active actor 才考虑 dependent（passive 不需要）。
- 第二层：`if(!curSpec->actorSpec[curArrayItem].bIndependent)`：只有非独立 actor 才是 dependent actor。

在 dependent 分支里：
- 逐项读取 `Dependent Passive Actor ID`、`Dependent Molecule Type`、`Dependent Trigger Mode/Value`、`Dependent Trigger on Rising Edge?`、`Dependent Relay *`；
- 每一项都做：
  - `cJSON_bItemValid` 类型检查；
  - 范围检查（比如 actor id 不能越界，molType 不能越界，mode 必须在可枚举范围内）；
  - 不合法就 warning + 赋默认值。

在 independent 分支里：
- 如果配置文件仍然写了 Dependent* 字段，你打印 warning 并忽略；
- 目的：避免用户误配导致“独立 actor 也被当成 dependent actor”。

#### 10.3.3 输出适配：按 `molPosX/Y/Z` 数组打印坐标

对应代码：[file_io.c:L3074-L3102](file:///Users/faner/Documents/AcCoRD-master/src/file_io.c#L3074-L3102)

逐行解释：
- `if (actorCommonArray[curActor].spec.bRecordPos[curMolType])`：只有当该 molType 配置为记录坐标时才打印 Position 段。
- `if(curObs->item.molPosX != NULL && ... && curObs->item.molPosZ[curMolInd] != NULL)`：
  - 确保三数组都存在，且当前 molInd 的数组也存在；
  - 这是为“有些 observation 可能不记录位置”的情况做防御。
- `for(curPos = 0; curPos < curObs->item.paramUllong[curMolInd]; curPos++)`：
  - `paramUllong[curMolInd]` 是该次观测的计数，也就是数组长度；
  - 你用它做循环上界，避免越界。
- `fprintf(out, "(%e, %e, %e) ", molPosX[curMolInd][curPos], ...)`：逐个打印每个分子坐标。

---

### 10.4 `src/accord.c`：依赖触发 + AF 映射 + heapTimerUpdate（逐行）

对应代码主块：[accord.c:L772-L947](file:///Users/faner/Documents/AcCoRD-master/src/accord.c#L772-L947)

这段代码发生在“被动 actor 完成一次观测并写入 curMolObs”之后，所以它的语义是：
> 每一次观测结束，都立即检查：有没有 dependent active actor 需要被这次观测触发？

逐行解释（按逻辑块）：

**(A) 遍历所有 active actor，找到依赖当前 passive 的那一个**
- `for(curActive = 0; curActive < NUM_ACTORS_ACTIVE; curActive++)`：扫描所有 active actor 的运行态数组。
- `short depActorID = actorActiveArray[curActive].actorID;`：
  - activeArray 的索引 `curActive` 不是 common actor id；
  - 这里取回 common actor id（后续访问 `actorCommonArray[depActorID].spec.*` 需要它）。
- 一串 `continue`：
  - 跳过 independent actor（不需要依赖触发）；
  - 跳过 passive actor（这里要触发的是 active）；
  - 跳过 dependentPassiveActorID 不等于当前被动 actor 的；
  - 跳过尚未到 startTime 的；
  - 跳过超过 maxAction 的。

**(B) 从 passive 的观测里取出该 dependent actor 关心的 depCount**
- `depMolType = actorCommonArray[depActorID].spec.dependentMolType;`：指定要看哪种分子计数。
- 遍历 `actorPassiveArray[curPassive].molRecordID[]` 找到对应 molType 的索引；
- `depCount = actorPassiveArray[curPassive].curMolObs[curMolPassive];`：取出计数。

**(C) Trigger：两种触发模式**
- `depMode = ... dependentTriggerMode;`
- `if(depMode == 1)`：增量阈值触发：
  - `prevCount = actorActiveArray[curActive].depPrevCount;`
  - `depCount >= prevCount + dependentTriggerValue` 才触发
  - 触发后无论是否触发都更新 `depPrevCount = depCount`（让下一次增量从这次开始累计）
- `else`：阈值触发：
  - `depAbove = depCount >= dependentTriggerValue;`
  - 若 `bDependentRisingEdge`：
    - 仅在 `depAbove && !depPrevAbove` 时触发（上升沿）
    - 然后 `depPrevAbove = depAbove`
  - 否则：
    - 只要 `depAbove` 就触发
    - 同样更新 `depPrevAbove = depAbove`
  - 并在末尾把 `depPrevCount` 同步为当前 depCount（除了 depMode==1 的分支已经同步过）

**(D) Relay：是否 AF 映射强度**
- `relayMode = dependentRelayMode;`
- `if(relayMode == 0)`：
  - `newRelease(...)`：完全沿用 upstream 强度生成（基于调制比特）。
- `else`：
  - 计算 `obsValue`：
    - relayMode==2：`obsValue = depCount - prevCount`（并处理 depCount < prevCount 时的负值）
    - 否则：`obsValue = depCount`
  - 计算 `strength = gain * obsValue + bias`
  - clamp 到 min/max：
    - `if(strength < min) strength = min;`
    - `if(strength > max) strength = max;`
  - `newReleaseWithStrength(..., strength)`：用覆盖强度创建 release。

**(E) 更新 dependent actor 的 timer，并立刻维护 heap**
- `actorActiveArray[curActive].nextNewReleaseTime = INFINITY;`
- `actorActiveArray[curActive].bNextActionNewRelease = false;`
  - 这两行的语义是：dependent actor 的下一事件不是“新符号开始”，而是“当前 release 的下一次 emission”。
- `timerArray[depActorID].nextTime = actorActiveArray[curActive].nextEmissionTime;`
- `actorCommonArray[depActorID].nextTime = timerArray[depActorID].nextTime;`
- `heapTimerUpdate(... timerArray[depActorID].heapID ...)`：
  - 这是修复点：如果你不更新 heap，主循环可能仍按旧顺序取事件，从而出现 dependent actor 触发后“迟迟不执行 emission”或执行顺序错乱。

---

### 10.5 `src/timer_accord.c`：`updateTimer` 的语义收敛

对应代码：[timer_accord.c:L121-L130](file:///Users/faner/Documents/AcCoRD-master/src/timer_accord.c#L121-L130)

逐行解释：
- `if(curTimer < 0 || curTimer >= NUM_TIMERS) return;`：防止越界。
- `timerArray[curTimer].nextTime = tCur;`：只做一件事：写 nextTime。

为什么要这么收敛：
- 你在多个地方（尤其 dependent actor 触发后）需要“写 nextTime + 立刻 heapTimerUpdate”；
- 把 `updateTimer` 做成纯赋值，调用者就更清楚“堆维护不是隐式发生的”，减少调试黑盒。

---

### 10.6 `src/file_io.h`：跨平台 `_WIN32` 条件包含 `<direct.h>`

对应代码：[file_io.h:L126-L128](file:///Users/faner/Documents/AcCoRD-master/src/file_io.h#L126-L128)

逐行解释：
- `#ifdef _WIN32`：只在 Windows 编译器定义 `_WIN32` 时进入。
- `#include <direct.h>`：Windows 的 `_mkdir()` 所需头文件。
- `#endif`：macOS/Linux 下不会 include，从而避免 “direct.h not found”。

---

### 10.7 `config/accord_config_sample.txt`：样例配置加入 dependent/AF 字段

对应代码：[accord_config_sample.txt:L73-L100](file:///Users/faner/Documents/AcCoRD-master/config/accord_config_sample.txt#L73-L100)

逐行解释（只解释你新增的键）：
- `"Dependent Passive Actor ID": 1`：第 3 个 actor 依赖 id=1 的 passive actor（样例里第 2 个 actor）。
- `"Dependent Molecule Type": 0`：观测分子类型 0。
- `"Dependent Trigger Mode": 0`：阈值触发。
- `"Dependent Trigger Value": 1`：阈值为 1。
- `"Dependent Trigger on Rising Edge?": true`：只在从未达阈到达阈的那一刻触发一次。
- `"Dependent Relay Mode": 1`：AF 模式：strength 与绝对计数成线性关系。
- `"Dependent Relay Gain": 1` / `"Dependent Relay Bias": 0`：strength = depCount。
- `"Dependent Relay Min Strength": 0`：负强度钳到 0。
- `"Dependent Relay Max Strength": 1e9999`：近似无上限（但仍提供字段，方便学生改成有限值测试 clamp）。

